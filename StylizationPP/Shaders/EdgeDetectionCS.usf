#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

// SceneColor texture
Texture2D OriginalSceneColor;

// SceneColor Viewport parameters
SCREEN_PASS_TEXTURE_VIEWPORT(SceneColorViewport)

// Output
RWTexture2D<float4> Output;

// Offsets for 4-neighbor Laplacian kernel
static const int2 LaplacianOffsets[4] =
{
    int2(-1, 0),
    int2(1, 0),
    int2(0, -1),
    int2(0, 1)
};

// Compute Shader code
[numthreads(THREADS_X, THREADS_Y, THREADS_Z)]
void MainCS(uint2 DispatchThreadId : SV_DispatchThreadID)
{
    if (any(DispatchThreadId >= SceneColorViewport_ViewportMax))
    {
        return;
    }

    // UV for center pixel
    float2 sampleUV = (float2(SceneColorViewport_ViewportMin) + (DispatchThreadId + 0.5)) *
                      SceneColorViewport_ExtentInverse;

    float3 center = OriginalSceneColor.SampleLevel(GlobalPointClampedSampler, sampleUV, 0).rgb;

    // Start Laplacian accumulation
    float3 lap = -4 * center;

    // Offsets for your kernel:
    const int2 Offsets[4] =
    {
        int2(0, -1), // up
        int2(0, 1), // down
        int2(-1, 0), // left
        int2(1, 0) // right
    };

    // Add neighbor values
    [unroll]
    for (int i = 0; i < 4; i++)
    {
        int2 np = int2(DispatchThreadId) + Offsets[i];
        np = clamp(np, SceneColorViewport_ViewportMin, SceneColorViewport_ViewportMax - 1);

        float2 nuv = (float2(np) + 0.5) * SceneColorViewport_ExtentInverse;

        float3 v = OriginalSceneColor.SampleLevel(GlobalPointClampedSampler, nuv, 0).rgb;

        lap += v; // weight = 1
    }

    // Edge strength
    float edge = length(lap);
    edge *= 3.0; // adjust strength
    edge = saturate(edge);

    // White lines on black background
    float4 OutputColor = float4(edge, edge, edge, 1.0);
    
    Output[SceneColorViewport_ViewportMin + DispatchThreadId] = OutputColor;
}